// Copyright (c) Improbable Worlds Ltd, All Rights Reserved

package log

import (
	"bufio"
	"bytes"
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/tatsushid/termdeco"
)

var (
	startTime = time.Now()
)

// humanFormatter formats log entries in a way suited for a human running a program in a terminal.
//
// Some examples, as generated by improbable.io/lib/log/demo:
//
//   +000 Going to show some swag logging
//   ERRO Dangerzone
//      > time=2017-04-27T09:56:59+01:00
//   WARN Careful now
//      > time=2017-04-27T09:57:01+01:00 some-info=field and combo error stack together
//      ! error (Internal): your argument is bad
//           this is bad
//      ! {code = Internal details = {
//      !    {code = InvalidArgument desc = your argument is bad}
//      !    {code = InvalidArgument desc = this specific thing was bad}
//      !    {code = Internal desc = this is bad}}}
type humanFormatter struct{}

type colorizer func(v interface{}) *termdeco.Decorator

func (f humanFormatter) Format(entry *logrus.Entry) ([]byte, error) {
	b := &bytes.Buffer{}

	color, indent := f.writePrefix(b, entry)
	f.writeMsg(b, entry, indent)
	f.writeFields(b, entry, color, indent)
	f.writeError(b, entry, color, indent)
	b.WriteRune('\n')
	return b.Bytes(), nil
}

func (f humanFormatter) writePrefix(buf *bytes.Buffer, entry *logrus.Entry) (colorizer, string) {
	// choose color for log level
	var color colorizer
	switch Level(entry.Level) {
	case DebugLevel:
		color = termdeco.White
	case InfoLevel:
		color = termdeco.Blue
	case WarnLevel:
		color = termdeco.Yellow
	case ErrorLevel:
		color = termdeco.Red
	case FatalLevel:
		color = termdeco.Red
	case PanicLevel:
		color = termdeco.Red
	default:
		color = termdeco.Yellow
	}

	prefix := strings.ToUpper(entry.Level.String()[:4])
	switch Level(entry.Level) {
	case WarnLevel, ErrorLevel, FatalLevel, PanicLevel:
		// for serious levels, print colored prefix and full timestamp
		fmt.Fprint(buf, color(prefix))
	default:
		if f.isSuccess(entry) {
			prefix = "DONE"
			color = termdeco.Green
		} else {
			// replace prefix with time-delta since start
			prefix = fmt.Sprintf("%+04d", int(entry.Time.Sub(startTime).Seconds()))
		}
		fmt.Fprint(buf, color(prefix))
	}

	indent := strings.Repeat(" ", len(prefix))
	return color, indent
}

func (f humanFormatter) isSuccess(entry *logrus.Entry) bool {
	_, ok := entry.Data[SuccessField]
	return ok
}

func (f humanFormatter) writeMsg(buf *bytes.Buffer, entry *logrus.Entry, indent string) {
	// render message, ensuring multiline messages are properly indented
	lines := bufio.NewScanner(bytes.NewBuffer([]byte(entry.Message)))
	firstLine := true
	for lines.Scan() {
		if !firstLine {
			buf.WriteRune('\n')
			buf.WriteString(indent)
		}
		buf.WriteRune(' ')
		buf.WriteString(lines.Text())
		firstLine = false
	}
}

func (f humanFormatter) writeFields(buf *bytes.Buffer, entry *logrus.Entry, color colorizer, indent string) {
	var keys []string
	for k := range entry.Data {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	onFieldLine := false
	writeField := func(k string, v interface{}) {
		// the first time we need to print a general field, print the field line's prefix
		if !onFieldLine {
			buf.WriteRune('\n')
			buf.WriteString(indent[:len(indent)-1])
			fmt.Fprint(buf, color(">"))
			onFieldLine = true
		}
		onFieldLine = true
		fmt.Fprintf(buf, " %s=%+v", termdeco.Bold(k), v)
	}

	switch Level(entry.Level) {
	case DebugLevel, InfoLevel:
		// debug and info logs contain a time offset in their line prefix
		if !f.isSuccess(entry) {
			break
		}
		fallthrough
	default:
		// for warning and above, write a quasi-field to indicate the time
		writeField("time", entry.Time.Format(time.RFC3339))
	}

	// if present, render unknown fields as key-value pairs on the second line
	for _, k := range keys {
		switch k {
		case ErrorCodeKey, ErrorCodeStringKey:
			// if an error message is present will print code and message on a separate line
			if _, ok := entry.Data[ErrorKey]; ok {
				continue
			}
		case TagsField:
			// tags aren't useful for human output: the user knows what they're running
			continue
		case ErrorKey, ErrorStackKey:
			// this information is printed separately
			continue
		case SuccessField:
			if entry.Data[SuccessField] == "" {
				// success field is used for the coloring, only print it separately if non-empty.
				continue
			}
		case "version", "cli-version":
			// only print version information for errors and above
			switch Level(entry.Level) {
			case DebugLevel, InfoLevel, WarnLevel:
				continue
			}
		case "":
			continue
		}
		writeField(k, entry.Data[k])
	}
}

func (f humanFormatter) writeError(buf *bytes.Buffer, entry *logrus.Entry, color colorizer, indent string) {
	// render code and error on its own line
	if err, ok := entry.Data[ErrorKey]; ok {
		var code interface{}
		if c, ok := entry.Data[ErrorCodeStringKey]; ok {
			code = c
		} else if c, ok := entry.Data[ErrorCodeKey]; ok {
			code = c
		}
		buf.WriteRune('\n')
		buf.WriteString(indent[:len(indent)-1])
		fmt.Fprint(buf, color("!"))
		buf.WriteString(" error")
		if code != nil {
			fmt.Fprintf(buf, " (%s)", code)
		}
		fmt.Fprintf(buf, ": %s", err)
	}
	// render full error stack last, with proper indenting.
	if stack, ok := entry.Data[ErrorStackKey]; ok {
		stackStr := fmt.Sprint(stack)
		// if the stack contains only one line we assume its the same as the error we already printed.
		if strings.Contains(stackStr, "\n") {
			lines := bufio.NewScanner(strings.NewReader(stackStr))
			for lines.Scan() {
				line := lines.Text()
				buf.WriteRune('\n')
				buf.WriteString(strings.Repeat(" ", len(indent)-1))
				fmt.Fprint(buf, color("!"))
				buf.WriteRune(' ')
				buf.WriteString(line)
			}
		}
	}
}
