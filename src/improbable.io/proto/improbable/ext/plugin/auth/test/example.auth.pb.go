// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: improbable/ext/plugin/auth/test/example.proto

package improbable_ext_plugin_auth_test

import (
	context "context"
	errors "errors"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/empty"
	improbable_io_lib_oauth2_authctx "improbable.io/lib/oauth2/authctx"
	improbable_io_lib_oauth2_perms "improbable.io/lib/oauth2/perms"
	improbable_io_lib_perms "improbable.io/lib/perms"
	improbable_io_lib_perms_registry "improbable.io/lib/perms/registry"
	improbable_io_proto_improbable_ext_platform_auth_authorization "improbable.io/proto/improbable/ext/platform/auth/authorization"
	_ "improbable.io/proto/improbable/ext/plugin/auth"
	improbable_io_proto_improbable_ext_plugin_auth "improbable.io/proto/improbable/ext/plugin/auth"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

func init() {
	improbable_io_lib_perms_registry.RegisterPermissions("/improbable.ext.plugin.auth.test.MyService/UnaryMethod",
		[]improbable_io_proto_improbable_ext_plugin_auth.Permission{
			{
				Resource: "irn:example:123:{{.Req.Item}}:{{.Req.Project.Name}}",
				Action:   "example:{{.Req.Action}}",
			},
		},
	)
	improbable_io_lib_perms_registry.RegisterPermissions("/improbable.ext.plugin.auth.test.MyService/StreamMethod",
		[]improbable_io_proto_improbable_ext_plugin_auth.Permission{
			{
				Resource: "irn:example:123:{{.Req.Item}}:{{.Req.Dpl.Id}}",
				Action:   "example:{{.Req.Action}}",
			},
		},
	)
	improbable_io_lib_perms_registry.RegisterPermissions("/improbable.ext.plugin.auth.test.MyService/UnaryDelegationV1",
		[]improbable_io_proto_improbable_ext_plugin_auth.Permission{},
	)
	improbable_io_lib_perms_registry.RegisterPermissions("/improbable.ext.plugin.auth.test.MyService/UnaryDelegationV2",
		[]improbable_io_proto_improbable_ext_plugin_auth.Permission{},
	)
	improbable_io_lib_perms_registry.RegisterPermissions("/improbable.ext.plugin.auth.test.MyService/UnaryDelegationBoth",
		[]improbable_io_proto_improbable_ext_plugin_auth.Permission{},
	)
	improbable_io_lib_perms_registry.RegisterPermissions("/improbable.ext.plugin.auth.test.MyService/MyOpenRPC",
		[]improbable_io_proto_improbable_ext_plugin_auth.Permission{},
	)
}

// The arguments for this v1 permission check.
type Permits_V1_MyV1Delegation_Args struct {
	Deployment string
	Project    string
}

// Performs the delegated permission check described by delegation "MyV1Delegation".
func Permits_V1_MyV1Delegation(ctx context.Context, args Permits_V1_MyV1Delegation_Args) error {
	perm := fmt.Sprintf("[r]:prj/%v/dpl/%v", args.Project, args.Deployment)
	grant, err := improbable_io_lib_oauth2_perms.ParseGrant(perm)
	if err != nil {
		return err
	}
	if !improbable_io_lib_oauth2_authctx.Perms(ctx).Permits(grant) {
		return errors.New(fmt.Sprintf("perm %v denied for grants %v", perm, improbable_io_lib_oauth2_authctx.Perms(ctx)))
	}
	return nil
}

// The arguments for this permission check.
type Permits_V2_MyV2Delegation_Args struct {
	ComponentKey string
	Operation    string
}

func perm_V2_MyV2Delegation(args Permits_V2_MyV2Delegation_Args) (*improbable_io_proto_improbable_ext_platform_auth_authorization.RequiredPermission, error) {
	resource, err := improbable_io_lib_perms.UnmarshalResource(fmt.Sprintf("irn:iam:123:example:%v", args.ComponentKey))
	if err != nil {
		return nil, err
	}
	action, err := improbable_io_lib_perms.UnmarshalAction(fmt.Sprintf("iam:%v", args.Operation))
	if err != nil {
		return nil, err
	}
	return &improbable_io_proto_improbable_ext_platform_auth_authorization.RequiredPermission{
		Resource: resource,
		Action:   action,
	}, nil
}

// Performs the delegated permission check described by delegation "MyV2Delegation".
func Permits_V2_MyV2Delegation(ctx context.Context, authzClient improbable_io_proto_improbable_ext_platform_auth_authorization.AuthorizationServiceClient, args Permits_V2_MyV2Delegation_Args) (bool, error) {
	perm, err := perm_V2_MyV2Delegation(args)
	if err != nil {
		return false, err
	}
	resp, err := authzClient.Permits(ctx, &improbable_io_proto_improbable_ext_platform_auth_authorization.PermitsRequest{
		RequiredPermission: []*improbable_io_proto_improbable_ext_platform_auth_authorization.RequiredPermission{perm},
	})
	if err != nil {
		return false, err
	}
	return resp.Permitted, nil
}

// Performs the delegated batch permission check described by delegation "MyV2Delegation".
// Each arg in 'batchArgs' is individually checked, and the resulting array of bools contain the results in the order
// they are defined in 'batchArgs'.
func PermitsBatch_V2_MyV2Delegation(ctx context.Context, authzClient improbable_io_proto_improbable_ext_platform_auth_authorization.AuthorizationServiceClient, batchArgs []Permits_V2_MyV2Delegation_Args) ([]bool, error) {
	perms := make([]*improbable_io_proto_improbable_ext_platform_auth_authorization.RequiredPermission, len(batchArgs))
	for i, args := range batchArgs {
		perm, err := perm_V2_MyV2Delegation(args)
		if err != nil {
			return nil, err
		}
		perms[i] = perm
	}
	resp, err := authzClient.PermitsBatch(ctx, &improbable_io_proto_improbable_ext_platform_auth_authorization.PermitsBatchRequest{
		RequiredPermission: perms,
	})
	if err != nil {
		return nil, err
	}
	return resp.Permitted, nil
}

// The arguments for this v1 permission check.
type Permits_V1_MyDelegation_Args struct {
	Project string
}

// Performs the delegated permission check described by delegation "MyDelegation".
func Permits_V1_MyDelegation(ctx context.Context, args Permits_V1_MyDelegation_Args) error {
	perm := fmt.Sprintf("[r]:prj/%v", args.Project)
	grant, err := improbable_io_lib_oauth2_perms.ParseGrant(perm)
	if err != nil {
		return err
	}
	if !improbable_io_lib_oauth2_authctx.Perms(ctx).Permits(grant) {
		return errors.New(fmt.Sprintf("perm %v denied for grants %v", perm, improbable_io_lib_oauth2_authctx.Perms(ctx)))
	}
	return nil
}

// The arguments for this permission check.
type Permits_V2_MyDelegation_Args struct {
	Project string
}

func perm_V2_MyDelegation(args Permits_V2_MyDelegation_Args) (*improbable_io_proto_improbable_ext_platform_auth_authorization.RequiredPermission, error) {
	resource, err := improbable_io_lib_perms.UnmarshalResource(fmt.Sprintf("irn:spatialOS:?:project:%v", args.Project))
	if err != nil {
		return nil, err
	}
	action, err := improbable_io_lib_perms.UnmarshalAction("spatialOS:doSomethingToProject")
	if err != nil {
		return nil, err
	}
	return &improbable_io_proto_improbable_ext_platform_auth_authorization.RequiredPermission{
		Resource: resource,
		Action:   action,
	}, nil
}

// Performs the delegated permission check described by delegation "MyDelegation".
func Permits_V2_MyDelegation(ctx context.Context, authzClient improbable_io_proto_improbable_ext_platform_auth_authorization.AuthorizationServiceClient, args Permits_V2_MyDelegation_Args) (bool, error) {
	perm, err := perm_V2_MyDelegation(args)
	if err != nil {
		return false, err
	}
	resp, err := authzClient.Permits(ctx, &improbable_io_proto_improbable_ext_platform_auth_authorization.PermitsRequest{
		RequiredPermission: []*improbable_io_proto_improbable_ext_platform_auth_authorization.RequiredPermission{perm},
	})
	if err != nil {
		return false, err
	}
	return resp.Permitted, nil
}

// Performs the delegated batch permission check described by delegation "MyDelegation".
// Each arg in 'batchArgs' is individually checked, and the resulting array of bools contain the results in the order
// they are defined in 'batchArgs'.
func PermitsBatch_V2_MyDelegation(ctx context.Context, authzClient improbable_io_proto_improbable_ext_platform_auth_authorization.AuthorizationServiceClient, batchArgs []Permits_V2_MyDelegation_Args) ([]bool, error) {
	perms := make([]*improbable_io_proto_improbable_ext_platform_auth_authorization.RequiredPermission, len(batchArgs))
	for i, args := range batchArgs {
		perm, err := perm_V2_MyDelegation(args)
		if err != nil {
			return nil, err
		}
		perms[i] = perm
	}
	resp, err := authzClient.PermitsBatch(ctx, &improbable_io_proto_improbable_ext_platform_auth_authorization.PermitsBatchRequest{
		RequiredPermission: perms,
	})
	if err != nil {
		return nil, err
	}
	return resp.Permitted, nil
}
